{"version":3,"file":"vue-router-plus.js","sources":["../src/utils.js","../src/before/query-options.js","../src/store.js","../src/hook-wrapper.js","../src/vue-router-plus.js"],"sourcesContent":["export const cloneDeep = s => JSON.parse(JSON.stringify(s))","import { cloneDeep } from '../utils'\nconst queryOptions = to => {\n  if ('_f' in to.query) {\n    delete to.query['_f']\n  }\n  const queryOptions = to.meta.queryOptions\n  const formatedQuery = cloneDeep(to.query)\n  if (queryOptions) {\n    for (let queryName in queryOptions) {\n      const query = queryOptions[queryName]\n      const queryType = query.type\n      const queryDefaultValue = query.default\n      if (queryName in to.query && to.query[queryName] !== undefined) {\n        formatedQuery[queryName] = queryType(to.query[queryName])\n      } else {\n        formatedQuery[queryName] = queryDefaultValue\n      }\n    }\n  }\n  to.meta.query = formatedQuery\n}\n\nexport default queryOptions\n","export default {\n  _f: 1,\n  to: {},\n  from: {},\n  next: null\n}\n","import store from './store'\n\nconst createHref = location => {\n  if (typeof location === 'string') {\n    if (location.includes('?')) {\n      location += `&_f=${store._f++}`\n    } else {\n      location += `?_f=${store._f++}`\n    }\n    return location\n  }\n  if (typeof location === 'object') {\n    location.query = location.query || {}\n    location.query._f = store._f++\n    return location\n  }\n  return location\n}\n\nconst hookWrapper = fn =>\n  function(to, from, next) {\n    function _next(arg) {\n      if (_next._isUsed) {\n        throw new Error(\n          `[vue-router-plus] next callback is called more than twice,\"${from.fullPath}\" -> \"${to.fullPath}\"`\n        )\n      }\n\n      // tag the next function is used status\n\n      const newLocation = createHref(arg)\n      _next._isUsed = true\n      next(newLocation)\n    }\n    const _to = to\n    const _from = from\n\n    store.to = _to\n    store.from = from\n    store.next = _next\n\n    // use orginal context\n    const ret = fn.call(this, _to, _from, _next)\n    // 形参大于2个\n    if (fn.length > 2) {\n      if (ret && (ret.then || ret.subscribe)) {\n        next(\n          new Error(\n            `[vue-router-plus] can not use next() and (Promise or Observable) together${\n              fn.name ? ' -> ' + fn.name : ''\n            }`\n          )\n        )\n      }\n    } else {\n      if (ret === undefined) {\n        _next()\n        return\n      }\n      if (ret === false) {\n        return\n      }\n      // process promise\n      if (ret.then) {\n        ret\n          .then(() => {\n            _next()\n          })\n          .catch(e => {\n            _next(new Error(e))\n          })\n        return\n      }\n      // process subscribe\n      if (ret.subscribe) {\n        ret.subscribe(\n          () => {\n            _next()\n          },\n          e => {\n            _next(new Error(e))\n          }\n        )\n        return\n      }\n    }\n    return ret\n  }\nexport default hookWrapper\n","import VueRouter from 'vue-router'\nimport queryOptions from './before/query-options'\nimport innerPlusHook from './hook-wrapper'\nimport store from './store'\nlet isHistoryBF = false\n\nclass VueRouterPlus extends VueRouter {\n  static install(Vue) {\n    Vue.use(VueRouter)\n    window.addEventListener('popstate', () => {\n      isHistoryBF = true\n    })\n    Vue.mixin({\n      beforeCreate() {\n        if (this.$route) {\n          Vue.util.defineReactive(this, '$searchQuery', this.$route.meta.query)\n        }\n      },\n      // 修复有其他钩子影响query时需要同步变更\n      watch: {\n        $route(newRoute) {\n          if (newRoute.meta.query) {\n            this.$searchQuery = newRoute.meta.query\n          }\n        }\n      }\n    })\n  }\n  constructor(routeOptions) {\n    super(routeOptions)\n    this.beforeEach(queryOptions)\n  }\n  get isHistoryBF() {\n    return isHistoryBF\n  }\n  get to() {\n    return store.to\n  }\n  get from() {\n    return store.from\n  }\n  get next() {\n    return store.next\n  }\n  beforeEach(fn) {\n    return super.beforeEach(plusHook(fn))\n  }\n  beforeResolve(fn) {\n    return super.beforeResolve(plusHook(fn))\n  }\n  _calcNewLocation(location) {\n    const { route } = this.resolve(location)\n\n    const newLocation = {\n      path: route.path,\n      query: Object.assign(route.query, {\n        _f: store._f++\n      }),\n      params: route.params,\n      hash: route.hash\n    }\n    return newLocation\n  }\n\n  /**\n   * @param {string} mode replace|push\n   * @param {string|object} location\n   * @param {Function} onComplete\n   * @param {Function} onError\n   */\n  _goto(mode, location, onComplete, onError) {\n    isHistoryBF = false\n    const newLocation = this._calcNewLocation(location)\n    return super[mode](newLocation, onComplete, onError)\n  }\n  push(location, onComplete, onError) {\n    return this._goto('push', location, onComplete, onError)\n  }\n  replace(location, onComplete, onError) {\n    return this._goto('replace', location, onComplete, onError)\n  }\n  // // spa reload current Route and force get Data again\n  reload(onComplete, onError) {\n    const current = this.currentRoute\n    this.replace(current.fullPath, onComplete, onError)\n  }\n}\n\nexport const plusHook = innerPlusHook\nexport default VueRouterPlus\n"],"names":["queryOptions","to","query","s","meta","formatedQuery","JSON","parse","stringify","queryName","queryType","type","queryDefaultValue","undefined","_f","from","next","createHref","location","includes","store","_typeof","isHistoryBF","VueRouterPlus","routeOptions","beforeEach","Vue","use","VueRouter","window","addEventListener","mixin","beforeCreate","this","$route","util","defineReactive","watch","newRoute","$searchQuery","fn","plusHook","route","resolve","path","Object","assign","params","hash","mode","onComplete","onError","newLocation","_calcNewLocation","_goto","current","currentRoute","replace","fullPath","_next","arg","_isUsed","Error","_to","_from","ret","call","length","then","subscribe","name","e"],"mappings":"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"}