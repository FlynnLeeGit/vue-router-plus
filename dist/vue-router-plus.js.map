{"version":3,"file":"vue-router-plus.js","sources":["../src/utils.js","../src/before/query-options.js","../src/store.js","../src/hook-wrapper.js","../src/vue-router-plus.js"],"sourcesContent":["export const cloneDeep = s => JSON.parse(JSON.stringify(s))","import { cloneDeep } from '../utils'\r\nconst queryOptions = to => {\r\n  if ('_f' in to.query) {\r\n    delete to.query['_f']\r\n  }\r\n  const queryOptions = to.meta.queryOptions\r\n  const formatedQuery = cloneDeep(to.query)\r\n  if (queryOptions) {\r\n    for (let queryName in queryOptions) {\r\n      const query = queryOptions[queryName]\r\n      const queryType = query.type\r\n      const queryDefaultValue = query.default\r\n      if (queryName in to.query && to.query[queryName] !== undefined) {\r\n        formatedQuery[queryName] = queryType(to.query[queryName])\r\n      } else {\r\n        formatedQuery[queryName] = queryDefaultValue\r\n      }\r\n    }\r\n  }\r\n  to.meta.query = formatedQuery\r\n}\r\n\r\nexport default queryOptions\r\n","export default {\r\n  _f: 1\r\n}\r\n","import store from './store'\r\n\r\nconst createHref = location => {\r\n  if (typeof location === 'string') {\r\n    if (location.includes('?')) {\r\n      location += `&_f=${store._f++}`\r\n    } else {\r\n      location += `?_f=${store._f++}`\r\n    }\r\n    return location\r\n  }\r\n  if (typeof location === 'object') {\r\n    location.query = location.query || {}\r\n    location.query._f = store._f++\r\n    return location\r\n  }\r\n  return location\r\n}\r\n\r\nconst hookWrapper = fn =>\r\n  function(to, from, next) {\r\n    function _next(arg) {\r\n      if (_next._isUsed) {\r\n        throw new Error(\r\n          `[vue-router-plus] next callback is called more than twice,\"${from.fullPath}\" -> \"${to.fullPath}\"`\r\n        )\r\n      }\r\n\r\n      // tag the next function is used status\r\n\r\n      const newLocation = createHref(arg)\r\n      _next._isUsed = true\r\n      next(newLocation)\r\n    }\r\n    const _to = to\r\n    const _from = from\r\n\r\n    // use orginal context\r\n    const ret = fn.call(this, _to, _from, _next)\r\n    // 形参大于2个\r\n    if (fn.length > 2) {\r\n      if (ret && (ret.then || ret.subscribe)) {\r\n        next(\r\n          new Error(\r\n            `[vue-router-plus] can not use next() and (Promise or Observable) together${\r\n              fn.name ? ' -> ' + fn.name : ''\r\n            }`\r\n          )\r\n        )\r\n      }\r\n    } else {\r\n      if (ret === undefined) {\r\n        _next()\r\n        return\r\n      }\r\n      if (ret === false) {\r\n        return\r\n      }\r\n      // process promise\r\n      if (ret.then) {\r\n        ret\r\n          .then(() => {\r\n            _next()\r\n          })\r\n          .catch(e => {\r\n            _next(new Error(e))\r\n          })\r\n        return\r\n      }\r\n      // process subscribe\r\n      if (ret.subscribe) {\r\n        ret.subscribe(\r\n          () => {\r\n            _next()\r\n          },\r\n          e => {\r\n            _next(new Error(e))\r\n          }\r\n        )\r\n        return\r\n      }\r\n    }\r\n    return ret\r\n  }\r\nexport default hookWrapper\r\n","import VueRouter from 'vue-router'\r\nimport queryOptions from './before/query-options'\r\nimport innerPlusHook from './hook-wrapper'\r\nimport store from './store'\r\nlet isHistoryBF = false\r\n\r\nclass VueRouterPlus extends VueRouter {\r\n  static install(Vue) {\r\n    Vue.use(VueRouter)\r\n    window.addEventListener('popstate', () => {\r\n      isHistoryBF = true\r\n    })\r\n    Vue.mixin({\r\n      beforeCreate() {\r\n        if (this.$route) {\r\n          Vue.util.defineReactive(this, '$searchQuery', this.$route.meta.query)\r\n        }\r\n      },\r\n      beforeRouteUpdate(to, from, next) {\r\n        if (this.$route) {\r\n          this.$searchQuery = this.$route.meta.query\r\n        }\r\n        next()\r\n      }\r\n    })\r\n  }\r\n  constructor(routeOptions) {\r\n    super(routeOptions)\r\n    this.beforeEach(queryOptions)\r\n  }\r\n  get isHistoryBF() {\r\n    return isHistoryBF\r\n  }\r\n  beforeEach(fn) {\r\n    return super.beforeEach(plusHook(fn))\r\n  }\r\n  beforeResolve(fn) {\r\n    return super.beforeResolve(plusHook(fn))\r\n  }\r\n  _calcNewLocation(location) {\r\n    const { route } = this.resolve(location)\r\n\r\n    const newLocation = {\r\n      path: route.path,\r\n      query: Object.assign(route.query, {\r\n        _f: store._f++\r\n      }),\r\n      params: route.params,\r\n      hash: route.hash\r\n    }\r\n    return newLocation\r\n  }\r\n\r\n  /**\r\n   * @param {string} mode replace|push\r\n   * @param {string|object} location\r\n   * @param {Function} onComplete\r\n   * @param {Function} onError\r\n   */\r\n  _goto(mode, location, onComplete, onError) {\r\n    isHistoryBF = false\r\n    const newLocation = this._calcNewLocation(location)\r\n    return super[mode](newLocation, onComplete, onError)\r\n  }\r\n  push(location, onComplete, onError) {\r\n    return this._goto('push', location, onComplete, onError)\r\n  }\r\n  replace(location, onComplete, onError) {\r\n    return this._goto('replace', location, onComplete, onError)\r\n  }\r\n  // // spa reload current Route and force get Data again\r\n  reload(onComplete, onError) {\r\n    const current = this.currentRoute\r\n    this.replace(current.fullPath, onComplete, onError)\r\n  }\r\n}\r\n\r\nexport const plusHook = innerPlusHook\r\nexport default VueRouterPlus\r\n"],"names":["queryOptions","to","query","s","meta","formatedQuery","JSON","parse","stringify","queryName","queryType","type","queryDefaultValue","undefined","_f","createHref","location","includes","store","_typeof","isHistoryBF","VueRouterPlus","routeOptions","beforeEach","Vue","use","VueRouter","window","addEventListener","mixin","beforeCreate","this","$route","util","defineReactive","beforeRouteUpdate","from","next","$searchQuery","fn","plusHook","route","resolve","path","Object","assign","params","hash","mode","onComplete","onError","newLocation","_calcNewLocation","_goto","current","currentRoute","replace","fullPath","_next","arg","_isUsed","Error","_to","_from","ret","call","length","then","subscribe","name","e"],"mappings":";;;m7CAAO,ICCDA,EAAe,SAAAC,GACf,OAAQA,EAAGC,cACND,EAAGC,MAAH,ODHcC,ECKjBH,EAAeC,EAAGG,KAAKJ,aACvBK,GDNiBF,ECMSF,EAAGC,MDNPI,KAAKC,MAAMD,KAAKE,UAAUL,QCOlDH,MACG,IAAIS,KAAaT,EAAc,KAC5BE,EAAQF,EAAaS,GACrBC,EAAYR,EAAMS,KAClBC,EAAoBV,UACtBO,KAAaR,EAAGC,YAAiCW,IAAxBZ,EAAGC,MAAMO,GACpCJ,EAAcI,GAAaC,EAAUT,EAAGC,MAAMO,IAE9CJ,EAAcI,GAAaG,EAIjCX,EAAGG,KAAKF,MAAQG,KCnBH,CACbS,GAAI,GCCAC,EAAa,SAAAC,SACO,iBAAbA,GACLA,EAASC,SAAS,KACpBD,iBAAmBE,EAAMJ,MAEzBE,iBAAmBE,EAAMJ,MAEpBE,GAEe,WAApBG,EAAOH,IACTA,EAASd,MAAQc,EAASd,OAAS,GACnCc,EAASd,MAAMY,GAAKI,EAAMJ,KACnBE,GAEFA,GCZLI,GAAc,EAEZC;;uBAoBQC,8IACJA,KACDC,WAAWvB,4RArBHwB,GACbA,EAAIC,IAAIC,GACRC,OAAOC,iBAAiB,YAAY,WAClCR,GAAc,KAEhBI,EAAIK,MAAM,CACRC,wBACMC,KAAKC,QACPR,EAAIS,KAAKC,eAAeH,KAAM,eAAgBA,KAAKC,OAAO5B,KAAKF,QAGnEiC,2BAAkBlC,EAAImC,EAAMC,GACtBN,KAAKC,cACFM,aAAeP,KAAKC,OAAO5B,KAAKF,OAEvCmC,iDAWKE,wDACeC,EAASD,0CAErBA,2DACeC,EAASD,6CAErBvB,OACPyB,EAAUV,KAAKW,QAAQ1B,GAAvByB,YAEY,CAClBE,KAAMF,EAAME,KACZzC,MAAO0C,OAAOC,OAAOJ,EAAMvC,MAAO,CAChCY,GAAII,EAAMJ,OAEZgC,OAAQL,EAAMK,OACdC,KAAMN,EAAMM;;;;;;uCAWVC,EAAMhC,EAAUiC,EAAYC,GAChC9B,GAAc,MACR+B,EAAcpB,KAAKqB,iBAAiBpC,2BAC7BgC,kBAAMG,EAAaF,EAAYC,gCAEzClC,EAAUiC,EAAYC,UAClBnB,KAAKsB,MAAM,OAAQrC,EAAUiC,EAAYC,mCAE1ClC,EAAUiC,EAAYC,UACrBnB,KAAKsB,MAAM,UAAWrC,EAAUiC,EAAYC,kCAG9CD,EAAYC,OACXI,EAAUvB,KAAKwB,kBAChBC,QAAQF,EAAQG,SAAUR,EAAYC,8CA1CpC9B,SAzBiBM,GAuEfc,ED1DO,SAAAD,UAClB,SAAStC,EAAImC,EAAMC,YACRqB,EAAMC,MACTD,EAAME,cACF,IAAIC,2EACsDzB,EAAKqB,0BAAiBxD,EAAGwD,mBAMrFN,EAAcpC,EAAW4C,GAC/BD,EAAME,SAAU,EAChBvB,EAAKc,OAEDW,EAAM7D,EACN8D,EAAQ3B,EAGR4B,EAAMzB,EAAG0B,KAAKlC,KAAM+B,EAAKC,EAAOL,MAElCnB,EAAG2B,OAAS,EACVF,IAAQA,EAAIG,MAAQH,EAAII,YAC1B/B,EACE,IAAIwB,yFAEAtB,EAAG8B,KAAO,OAAS9B,EAAG8B,KAAO,UAKhC,SACOxD,IAARmD,cACFN,QAGU,IAARM,YAIAA,EAAIG,iBACNH,EACGG,MAAK,WACJT,cAEK,SAAAY,GACLZ,EAAM,IAAIG,MAAMS,UAKlBN,EAAII,sBACNJ,EAAII,WACF,WACEV,OAEF,SAAAY,GACEZ,EAAM,IAAIG,MAAMS,cAMjBN"}