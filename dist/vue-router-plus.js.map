{"version":3,"file":"vue-router-plus.js","sources":["../src/utils.js","../src/before/query-options.js","../src/store.js","../src/hook-wrapper.js","../src/vue-router-plus.js"],"sourcesContent":["export const cloneDeep = s => JSON.parse(JSON.stringify(s))","import { cloneDeep } from '../utils'\nconst queryOptions = to => {\n  if ('_f' in to.query) {\n    delete to.query['_f']\n  }\n  const queryOptions = to.meta.queryOptions\n  const formatedQuery = cloneDeep(to.query)\n  if (queryOptions) {\n    for (let queryName in queryOptions) {\n      const query = queryOptions[queryName]\n      const queryType = query.type\n      const queryDefaultValue = query.default\n      if (queryName in to.query && to.query[queryName] !== undefined) {\n        formatedQuery[queryName] = queryType(to.query[queryName])\n      } else {\n        formatedQuery[queryName] = queryDefaultValue\n      }\n    }\n  }\n  to.meta.query = formatedQuery\n}\n\nexport default queryOptions\n","export default {\n  _f: 1,\n  to: {},\n  from: {},\n  next: null,\n  _pageStage: {\n    num: 1,\n    start_timestamp: 0,\n    path: ''\n  },\n  maxRedirect: {\n    times: 20,\n    duration: 3000\n  }\n}\n","import store from './store'\nconst createHref = location => {\n  if (typeof location === 'string') {\n    if (location.includes('?')) {\n      location += `&_f=${store._f++}`\n    } else {\n      location += `?_f=${store._f++}`\n    }\n    return location\n  }\n  if (typeof location === 'object') {\n    location.query = location.query || {}\n    location.query._f = store._f++\n    return location\n  }\n  return location\n}\n\nconst hookWrapper = fn =>\n  function(to, from, next) {\n    function _next(arg) {\n      if (_next._isUsed) {\n        throw new Error(\n          `[vue-router-plus] next callback is called more than twice,\"${from.fullPath}\" -> \"${to.fullPath}\"`\n        )\n      }\n\n      // tag the next function is used status\n\n      const newLocation = createHref(arg)\n      _next._isUsed = true\n      next(newLocation)\n    }\n    const _to = to\n    const _from = from\n\n    store.to = _to\n    store.from = from\n    store.next = _next\n    if (store._pageStage.path === _to.path) {\n      store._pageStage.num++\n      let currentTimeStamp = new Date().getTime()\n      // 在当前路径下已持续跳转xx秒,跳转次数超过xx次\n      let currentDuration = currentTimeStamp - store._pageStage.start_timestamp\n      if (\n        currentDuration < store.maxRedirect.duration &&\n        store._pageStage.num > store.maxRedirect.times\n      ) {\n        // 清空记录栈信息\n        store._pageStage.path = ''\n        store._pageStage.num = 1\n        store._pageStage.start_timestamp = 0\n        throw new Error(`[vue-router-plus] current Page is reload to many times\n      }`)\n      }\n    } else {\n      // 路径变化,清空记录栈信息\n      store._pageStage.path = _to.path\n      store._pageStage.num = 1\n      store._pageStage.start_timestamp = new Date().getTime()\n    }\n    // use orginal context\n    const ret = fn.call(this, _to, _from, _next)\n    // 形参大于2个\n    if (fn.length > 2) {\n      if (ret && (ret.then || ret.subscribe)) {\n        next(\n          new Error(\n            `[vue-router-plus] can not use next() and (Promise or Observable) together${\n              fn.name ? ' -> ' + fn.name : ''\n            }`\n          )\n        )\n      }\n    } else {\n      if (ret === undefined) {\n        _next()\n        return\n      }\n      if (ret === false) {\n        return\n      }\n      // process promise\n      if (ret.then) {\n        ret\n          .then(() => {\n            _next()\n          })\n          .catch(e => {\n            _next(new Error(e))\n          })\n        return\n      }\n      // process subscribe\n      if (ret.subscribe) {\n        ret.subscribe(\n          () => {\n            _next()\n          },\n          e => {\n            _next(new Error(e))\n          }\n        )\n        return\n      }\n    }\n    return ret\n  }\nexport default hookWrapper\n","import VueRouter from 'vue-router'\nimport queryOptions from './before/query-options'\nimport innerPlusHook from './hook-wrapper'\nimport store from './store'\nlet isHistoryBF = false\n\nclass VueRouterPlus extends VueRouter {\n  static install(Vue) {\n    Vue.use(VueRouter)\n    window.addEventListener('popstate', () => {\n      isHistoryBF = true\n    })\n    Vue.mixin({\n      beforeCreate() {\n        if (this.$route) {\n          Vue.util.defineReactive(this, '$searchQuery', this.$route.meta.query)\n        }\n      },\n      // 修复有其他钩子影响query时需要同步变更\n      watch: {\n        $route(newRoute) {\n          if (newRoute.meta.query) {\n            this.$searchQuery = newRoute.meta.query\n          }\n        }\n      }\n    })\n  }\n  constructor(routeOptions, routeExtraOptions = {\n    maxRedirect: {\n      times: 20,\n      duration: 3000\n    }\n  }) {\n    super(routeOptions)\n    store.maxRedirect = routeExtraOptions.maxRedirect\n    this.beforeEach(queryOptions)\n  }\n  get isHistoryBF() {\n    return isHistoryBF\n  }\n  get to() {\n    return store.to\n  }\n  get from() {\n    return store.from\n  }\n  get next() {\n    return store.next\n  }\n  get maxRedirect() {\n    return this.maxRedirect\n  }\n  beforeEach(fn) {\n    return super.beforeEach(plusHook(fn))\n  }\n  beforeResolve(fn) {\n    return super.beforeResolve(plusHook(fn))\n  }\n  _calcNewLocation(location) {\n    const { route } = this.resolve(location)\n    const newLocation = {\n      path: route.path,\n      query: Object.assign(route.query, {\n        _f: store._f++\n      }),\n      params: route.params,\n      hash: route.hash\n    }\n    return newLocation\n  }\n\n  /**\n   * @param {string} mode replace|push\n   * @param {string|object} location\n   * @param {Function} onComplete\n   * @param {Function} onError\n   */\n  _goto(mode, location, onComplete, onError) {\n    isHistoryBF = false\n    const newLocation = this._calcNewLocation(location)\n    return super[mode](newLocation, onComplete, onError)\n  }\n  push(location, onComplete, onError) {\n    return this._goto('push', location, onComplete, onError)\n  }\n  replace(location, onComplete, onError) {\n    return this._goto('replace', location, onComplete, onError)\n  }\n  // // spa reload current Route and force get Data again\n  reload(onComplete, onError) {\n    const current = this.currentRoute\n    this.replace(current.fullPath, onComplete, onError)\n  }\n}\n\nexport const plusHook = innerPlusHook\nexport default VueRouterPlus\n"],"names":["queryOptions","to","query","s","meta","formatedQuery","JSON","parse","stringify","queryName","queryType","type","queryDefaultValue","undefined","_f","from","next","_pageStage","num","start_timestamp","path","maxRedirect","times","duration","createHref","location","includes","store","_typeof","isHistoryBF","VueRouterPlus","routeOptions","routeExtraOptions","beforeEach","Vue","use","VueRouter","window","addEventListener","mixin","beforeCreate","this","$route","util","defineReactive","watch","newRoute","$searchQuery","fn","plusHook","route","resolve","Object","assign","params","hash","mode","onComplete","onError","newLocation","_calcNewLocation","_goto","current","currentRoute","replace","fullPath","_next","arg","_isUsed","Error","_to","_from","Date","getTime","ret","call","length","then","subscribe","name","e"],"mappings":"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"}